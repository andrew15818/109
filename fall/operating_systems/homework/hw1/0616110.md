---
title: "Operating Systems Homework 1 Report"
author: [Andres Ponce, 0616110]
date: "2020-10-12"
titlepage: true,
titlepage-text-color: "FFFFFF"
titlepage-rule-color: "360049"
titlepage-rule-height: 0
titlepage-background: "background.pdf"
---

1. **What is a kernel? What are the differences between *mainline*, *stable*, and *longterm*?
 What is a kernel panic**

The **kernel** of the operating system refers to the program that is always running on the 
computer. The kernel might include software for CPU scheduling, file system management, etc...
which are integral to the normal operation of the system. There are different ways to release
an operating system kernel.

The **mainline** kernel is the kernel that is currently being worked on and developed. 
Since there is constant development work occurring on the mainline kernel, there are 
constant releases of this kernel.

Once the mainline kernel has been released and iterated on, it moves to be a **stable**
kernel. The stable kernel receives less updates than the mainline kernel, those usually 
being more significant bug fixes. 

The final step is becoming a **longterm** kernel. This kernel will be mostly be used for 
bugfixes for older versions of the operating system.

A big purpose of these releases and constant updates is to minimize the occurrence of 
**kernel panics**. These are errors which might have serious consequences on the operation 
of the kernel. The causes for a kernel panic might involve unrecoverable errors in
memory, drivers, or other kernel component.

2. **What are the differences between *building*, *debugging*, and *profiling*?**

**Building** the kernel refers to compiling the source operating system source code. 
In the second step of the homework, we download the kernel using the `wget` command. 
Then we further download additional required dependencies and compile the kernel source 
code using the `sudo make -j$(nproc)` command. This turns all the code in the 
corresponding Linux version to a bootable format.

Once we have built the kernel, we have to **debug** it. Like in any program, the operating
system is bound to have some flaws or unintended behavior, or *bugs*. However, since we are
compiling a pretty basic layer of software on which all our other programs run, it is quite 
different. To debug a kernel, we require one machine to make our changes and then we send 
our changes to another machine. 

While we first debug our program and then build it, we still have to measure its performance, 
which we call **profiling**. This process involves tracing the performance or measuring 
the number of system calls to identify potential performance bottlenecks. Programs such as
Valgrind can trace the amount of system memory used, and other such programs can help us
measure how well our programs perform.
